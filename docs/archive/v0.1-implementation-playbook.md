# V0.1 Implementation Playbook (Agent-Executable)

## 1. Objective

Build demo-ready standalone security scan experience:

`repo URL -> scan -> report -> poster -> share`

Constraints:

- Mobile-first
- Public report link
- Growth-friendly scoring
- Jike-first launch assets

## 2. Delivery Scope

1. Functional pages
   - `/scan`
   - `/scan/report/:id`
   - `/scan/poster/:id`
2. API endpoints
   - `POST /api/scan`
   - `GET /api/scan/:id`
   - `GET /api/scan/:id/poster`
3. Lightweight static scan logic
4. Share flow (copy link + poster + QR code)

## 3. Recommended Repo Structure

```txt
security-scan-site/
  docs/
  specs/
  changes/
  app/                      # Next.js App Router
    scan/page.tsx
    scan/report/[id]/page.tsx
    scan/poster/[id]/page.tsx
    api/scan/route.ts
    api/scan/[id]/route.ts
    api/scan/[id]/poster/route.ts
  lib/
    scan/
      rules.ts
      scoring.ts
      engine.ts
    qr.ts
    validation.ts
  data/
    reports/                # V0.1 demo persistence (JSON or sqlite)
```

## 4. API Contract

## 4.1 POST /api/scan

Request:

```json
{
  "repoUrl": "https://github.com/org/repo"
}
```

Response 200:

```json
{
  "scanId": "scan_xxx",
  "status": "completed"
}
```

Response 400:

```json
{
  "error": "invalid_repo_url"
}
```

## 4.2 GET /api/scan/:id

Response 200:

```json
{
  "id": "scan_xxx",
  "repoUrl": "https://github.com/org/repo",
  "score": 91,
  "grade": "A",
  "status": "safe",
  "summary": { "critical": 0, "high": 0, "medium": 1, "low": 2 },
  "findings": [],
  "engineVersion": "v0.1",
  "scannedAt": "2026-02-10T16:00:00.000Z"
}
```

Response 404:

```json
{
  "error": "scan_not_found"
}
```

## 4.3 GET /api/scan/:id/poster

Response 200:

```json
{
  "id": "scan_xxx",
  "headline": "Security Pass",
  "score": 91,
  "grade": "A",
  "status": "safe",
  "qrUrl": "https://.../scan/report/scan_xxx",
  "brandText": "BRAND_TBD"
}
```

## 5. Data Model (Minimal)

## 5.1 scans

1. `id` (string, primary key)
2. `repo_url` (string)
3. `status` (`completed|failed`)
4. `created_at` (ISO datetime)

## 5.2 findings

1. `scan_id` (string, foreign key)
2. `rule_id` (string)
3. `severity` (`critical|high|medium|low`)
4. `title` (string)
5. `file` (string)
6. `line` (number)
7. `snippet` (string)
8. `recommendation` (string)

## 5.3 reports

1. `scan_id` (string, primary key)
2. `score` (number, 0-100)
3. `grade` (`A|B|C`)
4. `status` (`safe|needs_review|risky`)
5. `summary` (json)
6. `engine_version` (string)
7. `scanned_at` (ISO datetime)

## 6. Scan Rules (V0.1)

Implement deterministic, low-complexity rules only.

1. Command execution patterns
   - `eval(`, `exec(`, `spawn(`, `child_process`
2. Download-and-run patterns
   - `curl ... | sh`, `wget ... | bash`
3. Possible hardcoded secrets
   - `api_key`, `secret`, `token`, long high-entropy literals

Rule output format:

1. rule id
2. severity
3. evidence location
4. short remediation

## 7. Scoring Strategy (Growth-Friendly)

1. Start from base score 90.
2. Deduct by severity weight:
   - critical: -20
   - high: -12
   - medium: -6
   - low: -2
3. Clamp score to `[0, 100]`.
4. Grade mapping:
   - A: `>= 80`
   - B: `60-79`
   - C: `< 60`
5. Status mapping:
   - safe: no critical/high
   - needs_review: has medium, no critical
   - risky: has critical or high above threshold

## 8. UI Execution Tasks

## 8.1 /scan page

1. URL input with validation
2. Submit action and loading state
3. Error states:
   - invalid URL
   - scan failed
4. Success redirect to `/scan/report/:id`

## 8.2 /scan/report/:id page

1. Hero block: score + grade + status
2. Summary counters by severity
3. Findings list (path + line + snippet)
4. Remediation section
5. Disclaimer section
6. Share actions:
   - copy link
   - open poster

## 8.3 /scan/poster/:id page

1. Social-first visual card
2. Same core content order as report hero
3. QR code block
4. Brand/domain placeholder block
5. Poster screenshot/export hook (optional in V0.1, but layout must be ready)

## 9. Agent Task Breakdown

## Task A: API skeleton

1. Create 3 API routes
2. Add request validation
3. Add structured error responses

Done when:

1. Postman/curl can create and fetch scan data
2. Error code paths are testable

## Task B: Scan engine

1. Build rule matcher and scoring module
2. Produce normalized report object

Done when:

1. At least 3 rules produce findings on fixture repo
2. Score/grade/status are deterministic

## Task C: Report UI

1. Build report page from API data
2. Implement mobile-first layout and typography hierarchy

Done when:

1. iPhone-width viewport is usable without horizontal scroll
2. Core information visible in first screen

## Task D: Poster UI + QR

1. Build poster page from same report source
2. Add QR code linked to report URL

Done when:

1. Scan on phone opens exact report URL
2. Poster card is screenshot-ready for Jike

## Task E: Share flow

1. Add copy-link action
2. Add social share entry

Done when:

1. Shared link opens public report without auth

## Task F: Jike launch kit

1. Draft 1 primary post + 2 hook variants
2. Define posting structure: image + link + CTA

Done when:

1. Founder account can post directly with prepared assets

## 10. Test Checklist (Execution)

1. Functional
   - create scan
   - load report
   - open poster
   - copy and open link
2. UX
   - mobile readability
   - no overflow breakage
3. Content
   - disclaimer visible
   - findings evidence visible
4. Share
   - QR to report works
   - poster visual is social-ready

## 11. Handoff Protocol for Any Developer/Agent

1. Read active spec first.
2. Execute tasks in order: A -> B -> C -> D -> E -> F.
3. Mark task status in `changes` file after each completion.
4. Do not add V0.2 features before all V0.1 acceptance checks pass.
